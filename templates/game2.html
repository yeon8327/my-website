<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>Beta</title>
  <style>
    body {
      background-color: black;
      color: white;
      font-family: 'Arial', sans-serif;
      text-align: center;
      padding-top: 30px;
    }
    canvas {
      background: #111;
      display: block;
      margin: 0 auto;
      border: 2px solid #444;
    }
    .message {
      margin-top: 10px;
      font-size: 1.2rem;
    }
    .reset-btn {
      margin-top: 15px;
      padding: 8px 16px;
      background: #ff0000;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    .reset-btn:hover {
      background: #cc0000;
    }
    .hint {
      margin-top: 12px;
      font-size: 1.1rem;
      color: #00ffcc;
    }
  </style>
</head>
<body>
  <h1>Brick Breaker</h1>
  <div id="root"></div>

  <!-- React & Babel CDN -->
  <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <!-- React Code -->
  <script type="text/babel">
    const { useEffect, useRef, useState } = React;

    function BrickBreaker() {
      const canvasRef = useRef(null);
      const [gameStarted, setGameStarted] = useState(false);
      const [gameOver, setGameOver] = useState(false);
      const [gameClear, setGameClear] = useState(false);
      const [restartKey, setRestartKey] = useState(0);

      useEffect(() => {
        if (!gameStarted) return;

        const canvas = canvasRef.current;
        const ctx = canvas.getContext('2d');

        const width = (canvas.width = 480);
        const height = (canvas.height = 320);

        let x = width / 2;
        let y = height - 30;
        let dx = 3.8;
        let dy = -3.8;
        const ballRadius = 10;

        const paddleHeight = 10;
        const paddleWidth = 75;
        let paddleX = (width - paddleWidth) / 2;

        let rightPressed = false;
        let leftPressed = false;

        const brickRowCount = 3;
        const brickColumnCount = 5;
        const brickWidth = 75;
        const brickHeight = 20;
        const brickPadding = 10;
        const brickOffsetTop = 30;
        const brickOffsetLeft = 30;

        const bricks = Array.from({ length: brickColumnCount }, (_, c) =>
          Array.from({ length: brickRowCount }, (_, r) => ({
            x: 0,
            y: 0,
            status: 1,
          }))
        );

        let animationRef;

        document.addEventListener('keydown', keyDownHandler);
        document.addEventListener('keyup', keyUpHandler);

        function keyDownHandler(e) {
          if (e.key === 'Right' || e.key === 'ArrowRight') rightPressed = true;
          else if (e.key === 'Left' || e.key === 'ArrowLeft') leftPressed = true;
        }

        function keyUpHandler(e) {
          if (e.key === 'Right' || e.key === 'ArrowRight') rightPressed = false;
          else if (e.key === 'Left' || e.key === 'ArrowLeft') leftPressed = false;
        }

        function collisionDetection() {
          let remaining = 0;
          for (let c = 0; c < brickColumnCount; c++) {
            for (let r = 0; r < brickRowCount; r++) {
              const b = bricks[c][r];
              if (b.status === 1) {
                if (
                  x + ballRadius > b.x &&
                  x - ballRadius < b.x + brickWidth &&
                  y + ballRadius > b.y &&
                  y - ballRadius < b.y + brickHeight
                ) {
                  dy = -dy;
                  b.status = 0;
                }
                if (b.status === 1) remaining++;
              }
            }
          }
          if (remaining === 0) {
            setGameClear(true);
            dx = 0;
            dy = 0;
            cancelAnimationFrame(animationRef);
          }
        }

        function drawBall() {
          ctx.beginPath();
          ctx.arc(x, y, ballRadius, 0, Math.PI * 2);
          ctx.fillStyle = '#820000';
          ctx.fill();
          ctx.closePath();
        }

        function drawPaddle() {
          ctx.beginPath();
          ctx.rect(paddleX, height - paddleHeight, paddleWidth, paddleHeight);
          ctx.fillStyle = '#965D5D';
          ctx.fill();
          ctx.closePath();
        }

        function drawBricks() {
          for (let c = 0; c < brickColumnCount; c++) {
            for (let r = 0; r < brickRowCount; r++) {
              if (bricks[c][r].status === 1) {
                const brickX = c * (brickWidth + brickPadding) + brickOffsetLeft;
                const brickY = r * (brickHeight + brickPadding) + brickOffsetTop;
                bricks[c][r].x = brickX;
                bricks[c][r].y = brickY;
                ctx.beginPath();
                ctx.rect(brickX, brickY, brickWidth, brickHeight);
                ctx.fillStyle = '#ff4444';
                ctx.fill();
                ctx.closePath();
              }
            }
          }
        }

        function draw() {
          ctx.clearRect(0, 0, width, height);
          drawBricks();
          drawBall();
          drawPaddle();
          collisionDetection();

          if (x + dx > width - ballRadius || x + dx < ballRadius) dx = -dx;
          if (y + dy < ballRadius) dy = -dy;
          else if (y + dy > height - ballRadius) {
            if (x > paddleX && x < paddleX + paddleWidth) {
              dy = -dy;
            } else {
              setGameOver(true);
              cancelAnimationFrame(animationRef);
              return;
            }
          }

          if (rightPressed && paddleX < width - paddleWidth) paddleX += 5;
          else if (leftPressed && paddleX > 0) paddleX -= 5;

          x += dx;
          y += dy;

          animationRef = requestAnimationFrame(draw);
        }

        draw();

        return () => {
          document.removeEventListener('keydown', keyDownHandler);
          document.removeEventListener('keyup', keyUpHandler);
          cancelAnimationFrame(animationRef);
        };
      }, [restartKey, gameStarted]);

      const handleStart = () => {
        setGameStarted(true);
      };

      const handleRestart = () => {
        setGameOver(false);
        setGameClear(false);
        setRestartKey(prev => prev + 1);
      };

      return (
        <div>
          <canvas ref={canvasRef} />
          {!gameStarted && (
            <div>
              <button className="reset-btn" onClick={handleStart}>게임 시작</button>
            </div>
          )}
          {gameOver && (
            <div>
              <div className="message">Game Over</div>
              <button className="reset-btn" onClick={handleRestart}>재시작</button>
            </div>
          )}
          {gameClear && (
            <div>
              <div className="message">Game Clear!</div>
              {/* 플레이어가 이겼을 때만 힌트 표시 */}
              <div className="hint">Password Hint: 4</div>
              <button className="reset-btn" onClick={handleRestart}>재시작</button>
            </div>
          )}
        </div>
      );
    }

    ReactDOM.createRoot(document.getElementById('root')).render(<BrickBreaker />);
  </script>
</body>
</html>
